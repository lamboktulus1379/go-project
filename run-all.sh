#!/bin/bash
# One-shot local deployment for gra.tulus.tech
# - Starts Go app on 10010 (TLS)
# - Installs Nginx site and certs
# - Reloads Nginx
# - Verifies health
set -euo pipefail

BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

say() { echo -e "${BLUE}[INFO]${NC} $*"; }
ok()  { echo -e "${GREEN}[OK]${NC}   $*"; }
warn(){ echo -e "${YELLOW}[WARN]${NC} $*"; }
err() { echo -e "${RED}[ERR]${NC}  $*"; }

PROJECT_DIR="$(cd "$(dirname "$0")" && pwd)"
DOMAIN=${DOMAIN:-gra.tulus.tech}
PORT=${APP_PORT:-10010}
SERVERS_DIR="/opt/homebrew/etc/nginx/servers"
CERTS_DIR="/opt/homebrew/etc/nginx/certs"
LOG_FILE="/tmp/go-app-10010.log"
PID_FILE="/tmp/go-app-10010.pid"

ensure_nginx()
{
  if ! command -v nginx >/dev/null 2>&1; then
    err "nginx not found. Please install via Homebrew (brew install nginx)."
    exit 1
  fi
}

ensure_certs()
{
  say "Ensuring SSL certs for Nginx..."
  sudo mkdir -p "$CERTS_DIR"
  # Prefer repo certs for domain if present
  if [[ -f "$PROJECT_DIR/certs/${DOMAIN}-cert.pem" && -f "$PROJECT_DIR/certs/${DOMAIN}-key.pem" ]]; then
    sudo cp "$PROJECT_DIR/certs/${DOMAIN}-cert.pem" "$CERTS_DIR/${DOMAIN}.pem"
    sudo cp "$PROJECT_DIR/certs/${DOMAIN}-key.pem" "$CERTS_DIR/${DOMAIN}-key.pem"
    ok "Copied ${DOMAIN} certs to $CERTS_DIR"
  else
    # Try mkcert to generate combined cert incl localhost
    if command -v mkcert >/dev/null 2>&1; then
      say "Generating local certs with mkcert..."
      mkdir -p "$PROJECT_DIR/certs"
      ( cd "$PROJECT_DIR/certs" && mkcert -install >/dev/null 2>&1 || true )
      ( cd "$PROJECT_DIR/certs" && mkcert "$DOMAIN" localhost 127.0.0.1 ::1 )
      # pick the most recent pair
      latest_pem=$(ls -t "$PROJECT_DIR/certs"/*+*.pem 2>/dev/null | head -n1 || true)
      latest_key=$(ls -t "$PROJECT_DIR/certs"/*+*-key.pem 2>/dev/null | head -n1 || true)
      if [[ -f "$latest_pem" && -f "$latest_key" ]]; then
        sudo cp "$latest_pem" "$CERTS_DIR/${DOMAIN}.pem"
        sudo cp "$latest_key" "$CERTS_DIR/${DOMAIN}-key.pem"
        ok "Generated and installed certs via mkcert"
      else
        warn "mkcert output not found; falling back to existing files if any"
      fi
    else
      warn "mkcert not installed; expecting certs already in $CERTS_DIR or proxy will fail"
    fi
  fi
}

install_site()
{
  say "Installing Nginx site for $DOMAIN -> https://127.0.0.1:$PORT"
  sudo mkdir -p "$SERVERS_DIR"
  sudo tee "$SERVERS_DIR/${DOMAIN}.conf" >/dev/null <<EOF
# Auto-generated by run-all.sh
server {
  listen 80;
  server_name $DOMAIN;
  return 301 https://\$host\$request_uri;
}

server {
  listen 443 ssl;
  http2 on;
  server_name $DOMAIN;

  ssl_certificate     $CERTS_DIR/${DOMAIN}.pem;
  ssl_certificate_key $CERTS_DIR/${DOMAIN}-key.pem;

  # Simple health endpoint served by Nginx (not the app)
  location /healthz { return 200 'ok'; add_header Content-Type text/plain; }

  location / {
    proxy_pass https://127.0.0.1:$PORT;
    proxy_set_header Host \$host;
    proxy_set_header X-Real-IP \$remote_addr;
    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
  # Forward Authorization so upstream sees Bearer tokens
  proxy_set_header Authorization \$http_authorization;
    proxy_ssl_verify off;
  proxy_read_timeout 300s;
  }
}
EOF
  ok "Site installed: $SERVERS_DIR/${DOMAIN}.conf"
}

reload_nginx()
{
  say "Testing nginx config..."
  sudo nginx -t -c /opt/homebrew/etc/nginx/nginx.conf >/dev/null
  ok "nginx config valid"
  if pgrep nginx >/dev/null 2>&1; then
    say "Reloading nginx..."
    sudo nginx -s reload
  else
    say "Starting nginx..."
    sudo nginx -c /opt/homebrew/etc/nginx/nginx.conf
  fi
  ok "nginx active"
}

kill_port()
{
  local p=$1
  local pids
  pids=$(lsof -ti tcp:"$p" 2>/dev/null || true)
  if [[ -n "${pids}" ]]; then
    warn "Killing processes on port $p: $pids"
    kill ${pids} 2>/dev/null || true
    sleep 1
    pids=$(lsof -ti tcp:"$p" 2>/dev/null || true)
    if [[ -n "${pids}" ]]; then
      warn "Force killing remaining: $pids"
      kill -9 ${pids} 2>/dev/null || true
      sleep 1
    fi
  fi
}

start_go()
{
  say "Starting Go app on $PORT (TLS)"
  kill_port "$PORT"
  # choose app certs
  local CERT="$PROJECT_DIR/certs/localhost.crt"
  local KEY="$PROJECT_DIR/certs/localhost.key"
  if [[ ! -f "$CERT" || ! -f "$KEY" ]]; then
    if [[ -f "$PROJECT_DIR/certs/localhost+2.pem" && -f "$PROJECT_DIR/certs/localhost+2-key.pem" ]]; then
      CERT="$PROJECT_DIR/certs/localhost+2.pem"
      KEY="$PROJECT_DIR/certs/localhost+2-key.pem"
    else
      warn "No local app certs found; generating self-signed..."
      mkdir -p "$PROJECT_DIR/certs"
      openssl req -x509 -newkey rsa:2048 -nodes -keyout "$PROJECT_DIR/certs/dev.localhost.key" -out "$PROJECT_DIR/certs/dev.localhost.crt" -days 365 -subj "/CN=localhost" -addext "subjectAltName=DNS:localhost,IP:127.0.0.1,IP:::1" >/dev/null 2>&1 || true
      CERT="$PROJECT_DIR/certs/dev.localhost.crt"
      KEY="$PROJECT_DIR/certs/dev.localhost.key"
    fi
  fi
  # spawn
  ( APP_PORT=$PORT TLS_ENABLED=1 TLS_CERT_FILE="$CERT" TLS_KEY_FILE="$KEY" GODEBUG=x509usefallbackroots=1 \
      nohup go run main.go > "$LOG_FILE" 2>&1 & echo $! > "$PID_FILE" )
  sleep 1
  # Wait for app to listen; allow override via APP_START_TIMEOUT (seconds)
  local TIMEOUT=${APP_START_TIMEOUT:-45}
  if ! lsof -nP -iTCP:"$PORT" -sTCP:LISTEN >/dev/null 2>&1; then
    warn "App not listening yet; waiting up to ${TIMEOUT}s..."
    for i in $(seq 1 $TIMEOUT); do
      sleep 1
      if lsof -nP -iTCP:"$PORT" -sTCP:LISTEN >/dev/null 2>&1; then break; fi
      # Also treat any HTTP response from / as readiness (even 404)
      local code
      code=$(curl -k -s -o /dev/null -w "%{http_code}" https://127.0.0.1:$PORT/ || true)
      if [[ -n "$code" && "$code" != "000" ]]; then break; fi
    done
  fi
  if lsof -nP -iTCP:"$PORT" -sTCP:LISTEN >/dev/null 2>&1; then
    ok "Go app listening on $PORT (PID $(cat "$PID_FILE" 2>/dev/null || echo '?'))"
  else
    # One last HTTP probe before failing
    local code
    code=$(curl -k -s -o /dev/null -w "%{http_code}" https://127.0.0.1:$PORT/ || true)
    if [[ -n "$code" && "$code" != "000" ]]; then
      ok "Go app responded with HTTP $code on / (treating as ready)"
    else
      err "Go app failed to start; see $LOG_FILE"
      tail -n 80 "$LOG_FILE" || true
      exit 1
    fi
  fi
}

verify()
{
  say "Probing local app..."
  curl -k -s -o /dev/null -w "LOCAL:%{http_code}\n" https://127.0.0.1:$PORT/ || true
  say "Probing via nginx ($DOMAIN)..."
  curl -k -s -o /dev/null -w "GRA:%{http_code}\n" https://$DOMAIN/ || true
}

main()
{
  say "One-shot deploy: $DOMAIN -> 127.0.0.1:$PORT"
  ensure_nginx
  ensure_certs
  install_site
  start_go
  reload_nginx
  verify
  echo
  ok "Done. Access: https://$DOMAIN (proxy) or https://localhost:$PORT (direct)"
  echo "Logs: $LOG_FILE  |  PID: $(cat "$PID_FILE" 2>/dev/null || echo '?')"
}

main "$@"
